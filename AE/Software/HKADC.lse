# The ADC128 is on NPCS0 of SPI1

\ FFFE4000 SPI1 :constant
SPI1 SPI1_CR :constant
SPI1 \ 04 + SPI1_MR :constant
SPI1 \ 08 + SPI1_RDR :constant
SPI1 \ 0C + SPI1_TDR :constant
SPI1 \ 30 + SPI1_CSR0 :constant

# Initialization
# Master mode, fixed PCS of zero
1 SPI1_MR !

# CPOL=1, NCPHA=0 (clock is idle high, sample bits on rising edge)
# 16 bit transfers, BITS field is 8
# SCBR is 3, for a 10 MHz clock

\ 381 SPI1_CSR0 !

# Enable SPI1

1 SPI1_CR !

# m HKMUX yields nothing
# Set the HKMUX bits to m
7 mask 5 << HKmask :constant
HKMUX : HKmask PIOA_CODR ! 5 7 >field PIOA_SODR !

# nextmux nextc HKX yields dat
# note that there's no wait for operation complete since
# HKMUX takes plenty of time.
HKX : 11 3 >field SPI1_TDR ! HKMUX SPI1_RDR @ \ fff &

4 hk-discard :constant
16 hk-sum :constant
1. 4096 hk-sum * float /. hk-norm :constant

# adcchan (HKDIS) yields adcchan
(HKDIS) : dup SPI1_TDR !
# adcchan HKDIS yields adcchan
HKDIS : hk-discard (HKDIS) iterate
# sum adcchan (HKSUM) yields sum adcchan
(HKSUM) : dup SPI1_TDR ! swap \ fff SPI1_RDR @ & + swap
# adcchan HKSUM yields sum
HKSUM : 0 swap hk-sum HKSUM iterate drop
# chan mux HKF yields frac
HKF : HKMUX 11 3 >field HKDIS HKSUM float hk-norm *.
